## 1주차 답안

###미나
1. 스프링 컨테이너의 생성 과정에 대해 설명하시오.<br></br>
    무엇을 사용하냐에 따라 2개로 나눠서 설명할 수 있을 것 같다.
    첫 번째는 @ComponentScan, @Component, @AutoWired를 사용하지 않았을 때의 경우다.
    스프링 컨테이너는 ApplicationContext 인터페이스를 상속하는 AnnotationConfigApplicationContext(Config.class) 생성자를 사용하면서 시작된다.
    이 과정을 통해 스프링 컨테이너가 생성된다. 그리고 파라미터에 들어가 있던 설정 정보 클래스 Config에서, @Bean이 등록되어 있는 메서드를 통해
    구현 객체를 생성하고 이를 스프링 컨테이너에 등록한다. 그래서 이 객체들을 스프링 빈이라고 말한다.
    마지막으로 이러한 스프링 빈을 사용하기 위해 ApplicationContext에서 getBean() 메서드를 통해 구현 객체를 사용할 수 있다. 
    
    두 번째는 스프링에서 기본적으로 사용하는 @ComponentScan, @Component, @AutoWired를 사용했을 경우다.
    물론 설정 정보 클래스인 Config가 있긴 있어야 하나, @Bean은 굳이 사용할 필요가 없다.
    스프링 빈에 등록하기 위해서 Config에 @ComponentScan을 붙이고, 스프링 빈으로 등록하고자 하고자 할 때 클래스에 @Component를 붙이면 된다. 여기서 주의할 점이 있다.
    우선, 이 @ComponentScan이 붙는 클래스를 기준으로 하위 패키지를 스캔하며 @Component가 있는지 확인한다. 그렇기 때문에 해당 설정 클래스의 위치를
    상위 패키지에 놓는 걸 추천하며, SpringBoot의 경우 @SpringBootApplication 내부에 @ComponentScan이 있기 때문에, 상위 패키지에서 전체를 컴포넌트 스캔을 한다.
    다시 원래 얘기로 돌아와서, 이렇게 @Component를 통해 스캔을 하며 스프링 컨테이너에 스프링 빈을 등록한 후, @Autowired를 통해 타입을 이용하여 매핑 후
    자동으로 주입을 완료함으로써 스프링 컨테이너에 스프링 빈을 등록 후, 자동 주입까지 완료를 할 수 있게 된다.


2. BeanFactory와 ApplicationContext에 대해 설명하시오<br></br>
   BeanFactory는 말 그대로 Bean를 생성하고, 조회하는 등 Bean에 대한 다양한 기능을 가지고 있는 최상위 인터페이스다.
   다만 스프링은 Bean에 대한 기능 외에도 다양한 기능들을 제공하고 있고, 그에 맞추어 ApplicationContext 인터페이스는 BeanFacotry를 상속받는다.
   그래서 BeanFactory와 ApplicationContext는 둘 다 스프링 컨테이너라고 부르지만, 자주 사용되는 인터페이스는 ApplicationContext다.
   이 ApplicationContext는 BeanFactory 외에도 동시에 다양한 인터페이스를 상속받아 더욱 많은 기능들을 제공해준다.
   가령, 국제화 기능(MessageSource)이나 환경 변수(EnvironmentCapable), 어플리케이션 이벤트(ApplicationEventPublisher),
   리소스 조회(ResourceLoader)이 있다.



3. 싱글톤 패턴과 싱글톤 컨테이너의 차이점에 대해 설명하시오<br></br>
   기본적으로 싱글톤 패턴은 싱글톤 컨테이너와 다르게 스프링에 종속되지 않은 디자인 패턴이다.
   코드 면에서 싱글톤 패턴을 살펴보자면, 우선 하나의 객체를 생성하고 그 객체만을 이용한다는 점에서는 둘 다 같다고 볼 수 있으나,
   싱글톤 패턴의 경우 private static final를 이용하여 객체를 생성하기 때문에 클라이언트 측에서 객체 생성을 할 수는 없다.
   하지만 클라이언트가 구체 클래스에 직접적으로 의존한다는 점과, 이로 인해 OCP를 위반할 가능성이 높으며 내부 속성 변경, 초기화가 어렵다는 점,
   private 생성자이기에 자식 클래스를 만들기 어렵다는 단점을 가지고 있다.
   이러한 단점들로 인해 싱글톤 패턴은 안티 패턴이라고 불린다.

    싱글톤 컨테이너는 이러한 객체지향 설계 원칙을 위반할 수 있는 싱글톤 패턴을 보완하면서 만든 스프링 컨테이너라고 볼 수 있다.
    싱글톤 컨테이너는 @Configuration을 통해 싱글톤 패턴을 보장받을 수 있는데, Annotaion proccesser를 이용하고, 해당 어노테이션을 사용함으로써
    AnnotationConfigApplicationContext에 넘긴 설정 정보 클래스에 대한 인스턴스가 생성된다.
    또한 이 인스턴스 생성 과정에서 바이트코드 조작, Reflection을 통해 @Bean이 붙은 메서드마다 스프링 빈이 존재하는지, 혹은 존재하지 않는지에 따라 객체를 동적
    으로 생성한다. 이러한 과정을 CGLIB라고 한다.
    @Configuration이 없을 때 싱글톤 패턴을 보장하는 CGLIB 기술이 적용되지 않고, Reflection을 이용한 빈의 중복 여부를 체크하지 않기 때문에
    여러 객체가 생성될 수 있다. 그래서 @Configuration이 싱글톤 컨테이너의 핵심이라고 이해하면 된다.

###희준
1. SOLID 원칙 정리하기.<br></br>
   1) SRP(Single Responsibility Principle) : 한 객체 당 하나의 책임만을 져야한다. 한 클래스가 다양한 기능을 담당할 수 있지만,
      컴포넌트를 쉽고 유연하게 변경하며 개발하는 것을 지향하는 객체지향 설계 상, 기능의 작은 변경에 큰 변화가 있다는 것은
      객체 간의 캡슐화가 제대로 이루어지지 않았다는 뜻으로 받아들일 수도 있을 것이다.
      2)OCP(Open Closed Princile) : 기능의 확장에는 열려 있고, 역할의 변경에는 닫혀 있어야 한다. 기능의 확장이 일어난다고 해서 이 구현 객체를
      사용하는 클라이언트는 이 객체에 어떠한 변화가 있는지, 존재하는지조차도 모른다. 하지만 역할의 변경이 일어날 때 기존의 역할을 구현하는 객체들에
      동시에 변경해야 하기 때문에, 객체 지향 프로그래밍은 초기 설계부터 이러한 부분을 고려해야 한다.
   2) LSP(Liskov Substitution Principle) : 다형성을 이용한 하위 클래스는 인터페이스 규약을 지켜야 한다. 좀 더 정확히 얘기하자면 역할과 구현을
      맡은 객체가 완전히 같은 구현을 하진 않지만, 비슷한 방향의 역할을 해야한다는 의미다. 가령 브레이크라는 기능에 대해 구현 객체가 이를 구현했는데
      속도를 줄이는 기능이 아닌 속도를 증가시키는 기능을 넣어버리는 식의 행위, 즉 클래스의 의도와 맞지 않는 작성을 해선 안된다는 의미다.
   3) ISP(Interface Segregation Principle) : 하나의 범용 인터페이스보다는 기능별로 특정 인터페이스 여러 개를 이용해야 한다.
      범용 인터페이스는 한 눈에 어떠한 기능이 있는지 확인할 수 있지만 명료하지 않고, 동시에 구현 객체가 구현해야 할 기능이 많아지게 되고, 기능의 변경이 일어날 시
      파급 효과가 매우 크다. 그래서 인터페이스를 각 기능별로 분리함으로써, 명확하게 구분할 수 있고 다른 인터페이스로 대체할 가능성도 높아진다.
   4) DIP(Dependency Inversion Principle) : 구체화가 아닌 추상화에 의존해야 한다. 이는 클라이언트가 구현 객체에 의존해서는 안된다는 얘기를 하는 것이다.
      객체 지향 프로그래밍 특성 상, 캡슐화로 인해 각 객체가 어떠한 기능을 구현하는지 알지 못해야 하는데, 구체화에 의존할 때 이러한 객체 지향 요소를
      어기게 된다. 즉, 역할(Role)에 의존해야 한다는 의미다.


2.  아래의 싱글톤 패턴 생성 코드에서 static으로 선언하는 이유를 정리하시오.<br></br>
    public class SingletonService {
    private static final SingletonService instance = new SingletonService();
    public static SingletonService getInstance() {
    return instance;
    }
    private SingletonService() {}

    싱글톤 패턴의 주 목적은 오로지 하나의 객체만을 사용할 수 있도록 만든다는 점에 있다. 그래서 private 접근 지시자를 이용하여 객체를 생성하였고,
    getInstance() 메서드를 통해 이 객체에만 접근할 수 있도록 만든 것이다. 또한 Static을 이용하여
    JVM의 Static Area 영역에 객체를 할당함으로써, 이 객체를 공유하며 사용할 수 있게 만들었다.


3. 의존관계 주입 방법 4가지와, 이 중에서 생성자 주입 방식이 권장되는 이유에 대해 설명하시오.<br></br>
   우선 주입이란, 스프링 컨테이너에 등록된 스프링 빈을 @Autowired 어노테이션이 붙은 (생성자, 필드, 일반 메서드, set메서드)와
   타입이 같은 스프링 빈을 찾아 매핑한다는 의미를 가지고 있다.

    생성자 주입 방식이 권장되는 이유에 대해 설명하기 위해서는, 다른 주입 방식을 설명할 필요가 있다.

   1. setXX 주입 방식
      우선 set메서드는 우리가 알고 있는 setter, 일반적으로 인스턴스에 값을 넣기 위해 자바빈 프로퍼티 규약을 이용한 주입 방식이다.
      이 방식은 선택, 변경 가능성이 있는 의존관계에 주로 사용되나, 실제로 그렇게 변경 가능성이 있는 경우는 거의 없다. 다만, 적어도 어플리케이션
      실행 후 종료 시점까지 의존관계가 변경될 수 있다는 것은, 역할 자체를 바꿀 수도 있다는 의미와 다름없고, 또한 public 접근 지시자로 인해
      메서드의 변경 시 의존 관계에 큰 문제가 발생할 수 있어 권장되지 않는다.

   2. 필드 주입 방식
      정말 간단하게 사용할 수 있지만, 외부에서 변경이 불가능하고, DI 프레임워크가 없으면 아무런 대처를 하지 못한다.

   3. 일반 메서드 주입 방식
      한 번에 여러 필드를 주입할 수 있지만, 거의 사용하지 않는다.

    이러한 방식들과 비교하여 생성자 주입을 권장하는 이유는 크게 2가지로 얘기할 수 있다.
    먼저, 누락이 되지 않는다. 해당 생성자의 파라미터에 매개변수를 넣기 위해 선언할 때 final을 붙임으로써 값이 설정되도록 컴파일 오류 시점에 막을 수 있게 만든다.
    그리고 생성자를 통해 객체 생성 시 1번만 호출되므로, 불변하다는 장점이 정말 크다. 그마나 set메서드를 사용하긴 하지만, set메서드 주입 방식은 public 접근 지시자로 인해 실수로 변경될 수 있기
    때문에, 그런 점에서 생성자 주입 방식이 의존관계를 고려할 때 매우 안정적이다.



###정우
1. 객체지향의 5대 원칙 중 OCP에 대해 설명하시오<br></br>
   OCP는 Open Closed Principle로써, 확장에는 열려있되, 변경에는 닫혀있어라는 원칙이다.
   이를 좀 더 풀어서 설명하자면, 객체 지향 프로그래밍의 특징 4가지(추상화, 캡슐화, 다형성, 상속)를 통해 만들어진 객체들은 각자의 기능을 가지고 있다.
   각 객체가 기능의 확장이 있더라도 상속받은 객체를 제외한 나머지 객체들은 이러한 확장에 대해서 아무런 영향을 받지 못한다.
   하지만 역할의 변경이 일어났을 때, 다형성을 이용한 하위 객체가 동시에 영향을 받게 되어 많은 코드의 변경이 불가피하다.
   그런 방면에서 보았을 때, 구현에 있어서 확장은 열려 있지만, 역할의 변경에는 닫혀있어야 한다는 얘기로 이해하였다.

2. 싱글톤 방식을 사용 시, 주의해야 할 점에 대해 설명하시오.<br></br>
   싱글톤 방식은 하나의 객체만을 사용할 수 있도록 만들어주는 패턴이기에, 무분별한 객체 생성을 막아주는 패턴이라 볼 수 있다.
   다만, 이렇게 1개의 객체만을 이용해야 하기 때문에, 누군가가 사용하면서 생긴 영향이 다른 사람들에게 가지 않아야 한다.
   그래서 상태를 유지할 만한 필드가 존재해선 안되며, 가급적 읽기만 하는 것이 좋고, 지역 변수, 파라미터, ThreadLocal 등을 이용하여
   영향을 가지 않게 주의해야 한다.


3. 의존 관계 주입 방법 4가지에 대해 설명.<br></br>
   위와 동일하여 별도로 적지는 않았습니다.

###민욱 
1. DI 컨테이너를 통해, 기존 자바 코드에 어떠한 문제를 해결할 수 있는지 설명하시오.<br></br>
   기존 자바 코드를 다형성에 맞추어 역할과 구현으로 구분지었을 때 생기는 문제점 중 하나는, 클라이언트가 구현 객체에
   직접적으로 의존한다는 것, 즉 DIP를 위반한다는 것이었다. 그렇기 때문에 이러한 구현 객체를 대신 생성하고
   관리하며, 의존관계를 연결할 방법이 필요했고, 이러한 역할을 담당할 수 있게 만들어주는 것이 DI 컨테이너였다.
   이를 통해 역할과 구현의 명확한 구분이 가능해졌다.

2.@Autowired는 @Bean과 어떠한 차이점이 있는지 설명하시오.<br></br>
    @Bean은 @Configuration 어노테이션이 있을 때 스프링 빈을 등록하기 위해 메서드 위에 사용하는 어노테이션이다.
    반변 @Autowired는 이렇게 생성된 스프링 빈과 클라이언트의 역할 담당 객체(?)와의 매핑을 통해 주입을 할 수 있도록 유도해주는 어노테이션이다.
    기본적으로 매핑 방식은 타입을 기준으로 진행되며, 만약 타입이 2개 이상이 나올 때 이름을 이용하여 확인을 한다.
    그래서 @Bean과 @Autowired는 차이라고 할 것이 없는 다른 어노테이션이다.

3. 빈 생명주기 콜백 시, @PostConstruct, @PreDestroy가 권장되는 이유에 대해 다른 방법과 비교하며 설명하시오.<br></br>
   우선 생명주기를 초기화 및 콜백을 하기 위한 방법은 3가지가 있다.
   첫 번째는 DisposableBean과 InitializingBean인데, 이 2개의 인터페이스를 구현하고, overriding을 통해 각각 afterPropertiesSet() 메서드와 destroy() 메서드를 만들 수 있다. 하지만
   스프링 전용 인터페이스이기 때문에 다른 외부 라이브러리에 적용할 수 없다는 점, 초기화, 소멸 메서드의 이름을 정할 수 없다는 점으로 인해 지금은 잘 사용되지 않는다.

    두 번째는 @Bean의 InitMethod와 destroyMethod 속성이다. 위의 InitializingBean과 desposableBean과 달리 이름의 제약이 없고, 스프링 코드에 의해 영향을 받지 않으며
    코드가 아닌 설정 정보를 이용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메서드를 적용할 수 있다. 또한 조금 특이한 점이 있는데, 종료 메서드의 기본값이 inferred(추론)으로
    되어 있어 close나 shutdown으로 시작하는 이름의 메서드를 자동 호출하여 별도로 명시해주지 않더라도 사용가능하다.

    마지막은 @PostConstruct와 @PreDestory다. 사실 이 방법이 가장 선호되는 이유 중 하나는, 스프링 어노테이션같지만 JSR - 250 기반 어노테이션이라 스프링이 아닌 다른 컨테이너에서
    사용할 수 있기 때문이다. 또한 컴포넌트 스캔과 잘 어울린다는 장점이 있다. 다만 아쉬운 점은 외부 라이브러리에 초기화, 종료 메서드를 적용할 수 없기 때문에
    그럴 때 @Bean의 initMethod와 destroyMethod를 사용하는 것을 권장한다.
