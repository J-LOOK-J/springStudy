
## 2주차 답안


### 희준

1. **HTTP 특징 4가지를 설명하시오.**
    - **요청하는 클라이언트와 응답하는 서버로 구성**
        - **클라이언트** : 서버와 이어진 모든 기기와 단말기에서 이용하는 웹에 접근하는 소프트웨어이며, 서버에 각종 컨텐츠를 요청하는 역할.
        - **서버** : 데이터를 포함하거나, 네트워크의 다른 컴퓨터에서 액세스하는 기능을 제공하는 컴퓨터 or 다른 기능이 있는 컴퓨터에게 서비스 or 기능을 제공하는 컴퓨팅 장치 or 서비스를 제공하는 소프트웨어가 실행되는 컴퓨터
    - **비연결성(Connectionless)**
        - 클라이언트와 서버가 한 번 연결 후, 클라이언트 요청에 대해 서버가 응답을 마치면, 연결을 끊어버리는 성질.
        - 연결의 유지로 인한 많은 리소스 낭비 방지
        - 연결이 계속해서 끊어지기 때문에, 연결/해제에 대한 오버헤드가 주로 발생한다.
        - KeepAlive로 주기적으로 연결을 유지한다. 이를 통해 네트워크 혼잡, 비용, latency를 감소시킨다.
            - HTTP 지속 연결(Persistent Connections)을 맺는 방법으로, HTTP/1.1부터 proxy 문제로 사용하고 있지 않지만, 사용하는 곳이 많아서 알 필요가 있다.
            - 서버가 바쁜 환경에서는, 주기적으로 패킷을 보내야 하는 KeepAlive 특성 상 메모리를 낭비하게 된다.
            - HTTP/1.1부터는 기본적으로 Persistent Connection을 맺으며, HTTP/1.1 어플리케이션에서는 Connection을 close하기 위해, 명시적으로 Connection: close 헤더를 입력해야 한다.
    - **무상태(Stateless)**
        - 비연결성으로 인해, 서버는 클라이언트를 식별할 수 없고, 이를 Stateless라고 한다. 그래서 매번 새로운 인증을 해야 하는데, 이에 대처하기 위한 여러 방법이 있다.
            - **쿠키 - 클라이언트**
                - 클라이언트에게 정보를 담은 쿠키를 전달하고, 클라이언트가 서버에게 요청을 할 때마다 쿠키를 함께 전달하여, 서버가 클라이언트를 식별하도록 한다.
            - **세션 - 서버**
                - 서버에서 사용자 정보를 저장하기 때문에, 쿠키보다 보안적으로 안전하다. 다만, 서버의 메모리를 많이 차지하고, 동시 접속자 수가 많으면 과부하의 원인이 된다.
            - **토큰(OAuth, JWT)**
                - 보호할 데이터를 토큰으로 치환하여, 원본 데이터 대신 토큰을 사용하는 기술.
                - 중간에 공격자로부터 토큰이 탈취당해도, 데이터에 대한 정보를 알 수 없기 때문에 보안성이 높은 기술이다.
    - **구조가 단순하여 확장이 가능**
        - 프로토콜이 처음 나왔을 당시, 컴퓨터의 성능이 그렇게 좋지 못해, 최대한 효율적으로 정보를 담아야 했다. 그래서 비트 기반의 프로토콜이었는데, 문자로 되어 있는 것이 아니었기 때문에, 사람이 해석하는 데 오랜 시간이 걸렸고, 이는 이용하기에 불편하고 확장이 힘든 원인 중 하나가 되었다.
        - 시간이 지나며 컴퓨터의 성능이 좋아진 이후, 문자 기반의 프로토콜이 나오며, 효율성은 이전에 비해 떨어지지만, 이해도가 훨씬 높아지고, 구조가 단순화되어, 지금처럼 쉽게 확장이 가능한 프로토콜이 되었다.

[[HTTP] keep alive란? (persistent connection에 대하여)](https://etloveguitar.tistory.com/137)

[[HTTP] HTTP 특성(비연결성, 무상태)과 구성요소 그리고 Restful API](https://victorydntmd.tistory.com/m/286)

<aside>
💡 **Scale up, Scale Out이란?**
인프라를 확장시키는 방법들로, 크기의 확장이냐, 개수의 확장이냐로 구분할 수 있다e.
Scale up같은 경우, 기존의 서버를 보다 높은 사양으로 업그레이드하는 방법으로 **수직 스케일링(Vertical scaling)**이라고 한다.
Scale out같은 경우, 비슷한 사양의 서버 개수를 늘림으로써, 데이터 용량의 증가와 함께 서버 부하의 분산으로 성능 향상을 얻을 수 있다. 서버를 추가 확장하기 때문에 **수평 스케일링(horizontal scaling)**이라 부른다.



- **Scale up**
    - 추가적인 네트워크 연결 없이 용량 증강이 가능하며, 관리 비용이나 운영 이슈가 적고, 비교적 쉽다.
    - 성능 향상에 한계가 있으며, 비용 부담이 크고, 부담량이 많아 서버에 문제 발생 시 큰 타격을 입는다. 또한 서버 교체 시에는 서비스를 이용할 수 없는 다운타임이 불가피하다.
- **Scale out**
    - 상황에 따라 필요한 만큼 서버를 추가하여, 용량과 성능을 쉽게 확장할 수 있다. 또한, 한 서버에서만 작업을 함으로써 생기는 부하를 다른 서버에 분산시킴으로써 성능을 증가시킬 수 있다.
    - 여러 노드를 연결해 병렬 컴퓨팅 환경을 구성 시, 아키텍처에 대한 높은 이해가 필요하다. 또한 여러 노드에 부하를 균등하게 분산시키기 위해, 로드 밸런싱(load balancing)이 필요하고, 노드를 확장할 수록, 문제 발생의 잠재 원인 또한 늘어난다.

그래서 결론은, 상황에 맞게 Scale out이나 Scale up 방식을 이용하면 된다.

[Scale-up과 Scale-out에 대해 알아보자!](https://tecoble.techcourse.co.kr/post/2021-10-12-scale-up-scale-out/)

</aside>

1. **쿠키, 세션 저장소 개념을 정리하시오**.
   HTTP는 요청과 응답으로 이루어지는 하나의 사이클이 끝난 후, 연결이 끊어지는 비연결성을 띄고 있고, 이에 따라 서버는 클라이언트를 식별할 수 없다. 하지만 클라이언트의 상태를 서버가 아닌 클라이언트에 저장함으로써, 필요할 때마다 데이터를 꺼내 서버에 전달하는 방식으로 HTTP의 단점을 보완하는 방법이 필요했다.



    그런 점에서 **쿠키란**, **클라이언트가 서버에게 요청한 값을 일시적으로 저장하는 키와 값이 들어있는 데이터 파일이라 볼 수 있다**. 쿠키는 인증 유효 시간이 존재하여, 브라우저가 종료되더라도 그 시간동안 인증이 유지되며, 클라이언트의 상태 정보를 로컬에 저장했다가 참조를 하며, 서버가 Reponse Header에 Set-Cookie 속성을 이용함으로써, 클라이언트에 쿠키를 전달할 수 있다. 또한 쿠키는 사용자가 요청하지 않아도 브라우저가 Request 시 Request Header에 쿠키를 넣어 자동으로 서버에 전송한다.
    
    이러한 쿠키는 XSS에 강하고, 데이터 유효 기간을 지정 가능하며, 대부분의 브라우저가 지원한다는 장점이 있다.
    
    다만, 이러한 쿠키는 4KB의 용량 제한이 있어서, 요청할 때마다 최대 4KB의 데이터를 사용하기 때문에 데이터 낭비가 될 수 있다. 또한 암호화가 되어 있지 않아, 유저 정보의 도난 위험 가능성이 있다. 특히 CSRF 위협에 약하다. 그리고 문자열만 저장 가능하다는 단점이 있다.
    
    이를 해결하기 위해 나온 것이 웹 스토리지다.
    
    - **웹 스토리지**
        
        HTML5부터, 클라이언트에 데이터를 저장할 수 있도록 만들어진 데이터 저장소로써, key와 value 형태로 데이터를 저장하고, 크게 로컬 스토리지와 세션 스토리지로 나눌 수 있다. 별도로 저장소를 만들었기 때문에, 서버에 불필요하게 데이터를 저장하지 않아도 된다는 점, 저장소 크기가 비교적 크다는 점, 문자열 이외의 객체들도 저장이 가능하다는 점, CORS 특성으로 CSRF로부터 안전하다는 장점이 있다.
        
        다만, HTML5 이상이어야 하고, 이전과 달리 XSS로부터 위험하다는 단점이 존재한다.
        
        - **로컬 스토리지**
            - 데이터 영구 저장이 가능하기 때문에, 자동 로그인처럼 지속적으로 필요한 데이터 저장이 필요 시에 사용된다. window.localStorage 객체를 사용한다.
        - **세션 스토리지**
            - 브라우저 탭/윈도우가 닫히면 스토리지가 초기화되기 때문에, 일회성 로그인같은, 일시적으로 필요한 데이터 저장이 필요할 때 사용된다. window.sessionStorage 객체를 사용한다.
    
    반면 **세션이란, 서버 측에서 관리하며, 클라이언트를 구분하기 위한 세션 ID를 의미**한다. 이러한 세션은 브라우저 접속 - 종료까지 인증상태가 유지되며, 별도로 시간을 설정할 수도 있다. 이 세션을 통해서 클라이언트에 맞추어 요구에 맞는 서비스를 제공할 수 있다. 또한 세션은 클라이언트에 비해 보안 면에서 좋지만, 사용자 수가 많아질 수록 서버 메모리를 많이 차지하기 때문에 성능 저하의 원인이 된다. 그래서 주로 세션은 보안이 중요한 경우 사용하는 편이다.
    
    세션은 세션 ID를 이용해야 되서 쿠키도 필요하게 되는데, 기본적인 동작 방식은 다음과 같다.
    
    1. 클라이언트가 서버 접속 시 세션 ID 발급
    2. 클라이언트는 쿠키를 통해 세션 ID를 저장한다.
    3. 클라이언트가 서버 요청 시, 쿠키의 세션 ID 또한 서버에 전달
    4. 서버가 세션 ID를 이용하여, 별도의 작업 없이 세션에 있는 클라이언트 정보를 가져온다.
    5. 해당 정보를 가지고 서버 요청을 처리하여 클라이언트에게 응답. 
    
    → XSS, CSRF에 대해 정리한 글을 참고하는 정도로 끝내자.
    
    [XSS와 CSRF 특징 및 차이](https://lucete1230-cyberpolice.tistory.com/23)
    
    [쿠키, 로컬 스토리지, 세션 스토리지](https://velog.io/@hs0217/%EC%BF%A0%ED%82%A4-%EB%A1%9C%EC%BB%AC-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%84%B8%EC%85%98-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80)
    
    [쿠키와 세션 그리고 로컬 스토리지와 세션 스토리지](https://racoonlotty.tistory.com/entry/%EC%BF%A0%ED%82%A4%EC%99%80-%EC%84%B8%EC%85%98-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%A1%9C%EC%BB%AC-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80%EC%99%80-%EC%84%B8%EC%85%98-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80)


1. **ETag 방식이 가능한 이유에 대해 설명하시오.**


    ETag란 Entity Tag의 줄임말로, 웹 캐시의 유효성 검증을 위해 사용된다. 리소스의 버전에 따른 고유값이 ETag가 되고, 업데이트 시 ETag의 값도 바뀌게 된다. 그래서 클라이언트에서 캐싱하고 있는 버전과, 서버에서 가지고 있는 버전이 동일하다면 서버는 내용 없이 304 Not Modified라는 상태코드만 응답을 주어 response body에 대한 트래픽을 아낄 수 있다.
    
    이러한 ETag 방식이 가능한 이유는 기본적으로 Hash 알고리즘을 이용하기 때문이다. 그래서 Hash 알고리즘의 특성 상, 고유한 값이 동일하지 않을 때, 그 값이 동일할 확률이 거의 없다.
    
    ETag도 상황에 따라 Weak ETag와 Strong ETag가 있는데, Weak ETag는 W/로 시작하고 리소스 내용이 유사한 경우 동일하다고 간주하고, 캐싱 성능을 최적화하는 데 도움을 준다. 반면, String ETag는 수식어가 따로 붙지 않으며, 바이트 대 바이트로 동일한 지 엄격한 검사를 한다. 그렇게 검사 후, 데이터의 변화가 없다면 304 Not Modified를, 데이터의 변화가 있다면 200 OK를 응답한다.
    
    **참고**
    
    [HTTP ETag에 대해 알아보자](https://jizard.tistory.com/449)
    
    [웹 서비스 캐시 똑똑하게 다루기](https://toss.tech/article/smart-web-service-cache)
    
    [8분쯤 - 인프런 | 질문 & 답변](https://www.inflearn.com/questions/572711/8%EB%B6%84%EC%AF%A4)
    
    [ETag - HTTP | MDN](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/ETag#Browser_compatibility)


---

### 정우

1. **HTTP 메서드를 활용하여 클라이언트에서 서버로 데이터를 전달하는 방식 2가지에 대해 설명하시오**

   클라이언트에서 서버로 데이터를 전달하는 방식은 크게 Query parameter를 통해 전달하는 방식과, 메시지 바디를 통해 전달하는 방식이 있다.

   Query Parameter의 경우, 주로 검색 필터에 사용되며 HTTP 메서드 중 GET 방식을 통해 사용하게 된다.

   반면 메시지 바디의 경우 POST, PATCH, PUT 등의 메서드를 통해 사용할 수 있으며, 주로 리소스 생성, 변경 등에 사용된다.

    <aside>
    💡 별도의 조치를 취하지 않는 경우, 메시지 바디를 통해 데이터를 전달하게 되는데, 데이터를 그대로 전달하면 외부 공격에 무방비하게 노출될 가능성이 높다.
    **그래서, 실무에서는 클라이언트에서 스크립트를 이용하여 복호화할 수 있는 암호 키를 생성한다. 그 후, 해당 키로 세션에서 복호화할 수 없는 암호를 생성한 후 DB에 저장을 하는 방식으로 대처를 한다.**

    </aside>


2. **Web server와 WAS의 차이에 대해 설명하시오.(추가 조사 필요)**

   Web Server와 WAS의 차이는 **정적 컨텐츠를 처리하느냐, 동적 컨텐츠를 처리하느냐**에 대한 차이다.

   Web Server에서는 HTTP 프로토콜을 기반으로 하여, 클라이언트의 요청을 서비스하는 기능을 가졌는데, WAS를 거치지 않고 바로 자원을 제공하며, 동적인 컨텐츠 제공을 위해 클라이언트의 요청을 WAS에게 보내고, 그 결과를 클라이언트에게 응답한다. 이러한 방식은 정적 컨텐츠만을 처리함으로써, 서버의 부담을 줄일 수 있다는 점에서 장점을 가지고 있다. 이러한 Web Server의 종류에는 Nginx, Apache가 대표적이다.

   반면 WAS는 DB 조회나 다양한 비즈니스 로직 처리 등을 필요로 하는 동적인 컨텐츠를 제공하기 위한 Application Server라고 볼 수 있다. 크게 Web Server와 Web Container를 합친 것이라고 보면 되는데, Web Server의 기능들을 구조적으로 분리하여 처리함으로써 서버 부하를 방지한다. 또한 Web Container가 요청정보를 실시간으로 파악하여 페이지에 필요한 파일을 생성한다. 이는 서버의 리소스 부하를 줄일 수 있게 한다. 그리고, 주로 여러 개의 트랜잭션(논리적인 작업 단위) 관리 기능을 담당하며, 업무를 처리하는 비즈니스 로직을 수행한다. 또한 자원 이용의 효율성 및 장애 극복, 배포 및 유지보수의 편의성을 위해 Web Server와 WAS를 분리한다.

    <aside>
    💡 **Apache와 Tomcat은 같은 것일까?**
    우리는 Spring Boot를 사용 시, Apache Tomcat를 사용한다고 얘기하곤 해서 2개가 같은 것이라고 쉽사리 착각한다. 하지만 엄연히 Apache와 Tomcat는 다른 서버다.
    **Apache Server(Web Server) ≠ Tomcat(WAS Server)**

   그렇다면, 2개를 연동해야 할 이유가 있을까?
   사실 그럴 필요는 없다. 정적인 컨텐츠, 동적 컨텐츠에 따라 서버를 구축하면 되지만, Apache 서버를 활용하여 기능이 다양하지 않은 Tomcat과 함께, 더욱 다양하고 복합적인 기능을 제공할 수 있다.

   [아파치(Apache)와 톰캣(Tomcat)의 차이점 및 이해(1)](https://ssd0908.tistory.com/entry/%EC%95%84%ED%8C%8C%EC%B9%98Apache%EC%99%80-%ED%86%B0%EC%BA%A3Tomcat%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90-%EB%B0%8F-%EC%9D%B4%ED%95%B41)

    </aside>

   [[Web] Web Server와 WAS의 차이와 웹 서비스 구조 - Heee's Development Blog](https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html)


1. **MVC 패턴에 대해 설명하시오**

   MVC 이전에는 하나의 JSP에 대부분의 역할이 몰려 있었다. 그 때는 사소한 변경에도 비즈니스 로직이 함께 있는 파일을 수정해야 한다. 또한 **변경 라이프 사이클**이 달라서, 유지보수가 어렵다는 단점이 존재했다. 또한 기능에 맞게 최적화되어 있는데, 다른 부분의 업무도 담당하는 것은 비효율적이기 때문에 MVC 패턴을 사용하게 되었다.

   MVC는 Model - View - Controller 구조로, **관심사의 분리를** 통해 더욱 더 쉬운 관리를 가능하게 한다. 그렇다면 각 역할에 대해 살펴보자.

    - **Model** : 뷰에 출력할 데이터를 담아두고, 뷰가 필요한 데이터를 모두 모델에 담아서 전달해주기 때문에, 뷰는 비즈니스 로직이나 데이터 접근을 몰라도 되고. 렌더링 하는 일에 집중할 수 있다.
    - **View** : 모델에 담겨있는 데이터를 사용하여 화면을 그리는 일에 집중한다.
    - **Controller** : HTTP 요청을 담아서 파라미터를 검증하고, **비즈니스 로직을 실행**한다. 그리고 뷰에 전달할 **결과 데이터를 조회하여 모델에 담는다**.

---

### 미나

1. **프로토콜 스택 4계층 TCP/IP에 대해 설명하시오**

   IT 엔지니어를 위한 네트워크 입문 - TCP/IP

   TCP/IP는 OSI 7계층을 기반으로 만들어졌으며, TCP와 IP를 기반으로 비교적 단순하며 가격이 낮고 성능이 좋아 대부분 어플리케이션에서 사용하는 프로토콜 스택이다. OSI 7 계층에서 어플리케이션 개발자가 고려해야 하는 부분과 네트워크 엔지니어가 고려해야 할 부분이 구분되었는데, TCP/IP 모델에서는 그 구분이 더 명확하게 드러난다. 이러한 TCP/IP는 크게 4개의 계층으로 구분할 수 있다.

    - 어플리케이션 계층(어플리케이션 계층 + 프레젠테이션 계층 + 세션 계층)
    - 트랜스포트 계층
    - 인터넷(네트워크 계층)
    - 네트워크 액세스(데이터 링크 계층 + 피지컬 계층)
      <br></br>
1. **3-Way-HandShake에 대해 설명하시오**

   **TCP의 목적인 유실없는 안전한 통신을 위한 사전 연결작업**을 3 Way HandShake라고 한다. 목적지가 데이터를 받을 준비가 되어 있는지를 패킷을 총 3번 주고 받으며 통신을 준비하게 된다. 이 사전 연결작업은 **SYN**(Synchronized sequence numbers), **ACK**(acknowledgment) 패킷을 통해 체크할 수 있는데, 작업 순서대로 설명을 해보자.

    1. 클라이언트는 서버에 접속을 요청하는 SYN 패킷을 보낸다. 이 때, 클라이언트는 SYN 패킷을 보내고 SYN/ACK 응답을 기다리는 **SYN_SENT** 상태가 된다. [SYN]
    2. 서버는 SYN 요청을 받고, 클라이언트에게 요청을 수락한다는 ACK와 SYN flag가 설정된 패킷을 발송하고, 클라이언트가 ACK로 응답하기를 기다린다. 이 때 서버는 **SYN_RECEIVED** 상태가 된다. [SYN + ACK]
    3. 클라이언트는 서버에게 ACK를 보내고, 이후로는 연결이 이루어지며 데이터가 오가게 된다. 이 때 서버의 상태와 클라이언트는 **ESTABLISHED** 상태가 된다. [ACK]

   [[ 네트워크 쉽게 이해하기 22편 ] TCP 3 Way-Handshake & 4 Way-Handshake](https://mindnet.tistory.com/entry/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-22%ED%8E%B8-TCP-3-WayHandshake-4-WayHandshake)


1. **HTTP header, body에 들어갈 수 있는 요소들을 설명하시오.**
    1. **HTTP header** : **HTTP 전송에 필요한 모든 부가 정보**가 들어가며, 메시지 바디의 내용, 크기, 압축, 인증, 요청 클라이언트 정보, 캐시 관리 정보 등이 들어간다.
    2. **HTTP body** : **실제 전송할 데이터**로, HTML 문서, 이미지, 영상, JSON 등 byte로 표현할 수 있는 모든 데이터를 전송 가능하다.

---

### 기타

1. **CORS**

   CORS(Cross-Origin Resource Sharing)에 대해 알기 전, Origin에 대해 먼저 알아볼 필요가 있다. Origin은 URL의 Protocol, Host, port를 합친 것으로 예시를 들면 [https://bangOol.github.io와](https://bangOol.github.io와) 같은 모습이라 볼 수 있다.

   이 때 CORS는 query parameter나 fragment가 다르다고 해서 출처가 달라지는 건 아니지만, Protocol, Host, Port가 달라지면 출처가 다르다고 인지된다.

   Postman, 다른 서버에서 API를 호출할 때는 괜찮더라도, 브라우저에서 API 호출 시 CORS policy 오류로 인해 고생할 수 있다. **그러한 이유는 브라우저가 동일 출처 정책(Same-Origin-Policy, SOP)를 지켜서, 다른 출처의 리소스 접근을 금지하기 때문이다.**

   물론 이러한 SOP도 장점은 있다. 외부 리소스를 가져오지 못한다는 불편함은 있더라도 XSS나 XSRF 등의 보안 취약점을 노린 공격을 방어할 수 있다. **다만 외부 리소스의 참고는 필요하기 때문에, 외부 리소스를 사용하기 위한 SOP의 예외 조항으로 CORS가 사용된다.**

    - **Simple Request**

      이 방법은 서버에게 바로 요청을 보내는 방법으로, 서버에 API를 요청하고, 서버는 Access-Control-Allow-Origin 헤더를 포함한 응답을 브라우저에 보낸다. 브라우저는 이 헤더를 확인하여 CORS 동작을 수행할 지 판단한다.

      이 때, 이 요청이 동작하기 위한 조건은 3가지가 있다.

        - 요청 메서드는 GET, HEAD, POST 중 하나여야 한다.
        - Accept, Accept-Language… 등 지정된 헤더 외에는 사용해선 안된다. (Authorization 헤더도 포함되어 있지 않아 까다로운 조건이다.)
        - Content-Type 헤더는 applicaiton/x-www-form-urlencoded, multipart/form-data, text/plain 중하나를 사용해야 한다. (많은 REST API가 Content-Type으로 application/json을 사용하기 때문에 힘든 조건이다)

    - **Preflight request**

      앞에서 이야기 한 CORS 동작 원리를 보면, 서버에서 `Access-Control-Allow-Origin` 헤더를 포함한 응답을 브라우저에 보내는 방식으로 CORS 에러를 해결할 수 있다. 프론트엔드 개발자가 CORS 에러를 확인했다면, 서버에 `Access-Control-Allow-Origin` 등 CORS를 해결하기 위한 몇 가지 응답 헤더를 포함해 달라고 요청해야한다.


    [[Browser] CORS란?](https://beomy.github.io/tech/browser/cors/)


1. **URL 인코딩, 디코딩**
    1. **URL Encoding**

       URL에서 URL로 사용할 수 없는 문자 혹은 URL로 사용할 수 있지만, 의미가 왜곡될 수 있는 문자들을 ‘%XX’,  UTF-8(16진수)로 변환하는 것을 의미한다.

    2. **URL Decoding**

       변환된 URL을 다시 원래 형태로 되돌리는 것을 의미한다.


    [[Web] URL 인코딩/디코딩 (URL Encoding/Decoding)](https://it-eldorado.tistory.com/143)


1. **SSL**

   SSL(**Secure Sockets Layer**), 보안 소켓 계층 인증서는 브라우저와 서버 사이의 암호화된 연결을 수립하는 데 사용된다. 우리 근처에서 흔히 볼 수 있는 HTTPS를 이용한 인터넷 접속이 SSL을 이용한 것이라고 이해하면 된다. 이러한 SSL 암호화는 비대칭키 방식으로 암호화에 사용할 키를 교환하고, 대칭키 방식으로 데이터 통신을 하는 면에서 굉장이 매력적인 방법이다.

   이 때 **SSL(TLS)는 보안 계층이라는 독립적인 프로토콜 계층을 만들어 어플리케이션 계층과 전송 계층 사이에 속하게 되는데**, 이를 통해 HTTP + SSL을 통해 보안된 HTTP 통신을 하게 되는 HTTPS 프로토콜이 만들어진다. 그리고 SSL과 FTP, SMTP 등과 같이 다른 프로토콜에도 적용가능하다.

   > TLS와 SSL은 같은 의미의 단어이며, TSL가 SSL의 후속작이지만, SSL이 더 일반적으로 쓰이는 용어다.
   >

   이러한 SSL 암호화 통신을 통해, 보안이 적용되는 과정을 살펴보면 다음과 같다.

    1. **handShake**

       데이터를 주고 받기 위해 어떠한 방법을 사용해야 하는지 서로의 상태를 파악한다. 이 때, HTTP는 80번 포트임에 반해, SSL은 443번 포트를 기본으로 사용하는 TCP 기반의 프로토콜이다. TCP 기반이기 때문에 handShake 전 TCP 3-way handShake 또한 수행한다.

       이 handShake의 과정은 다음과 같다.

        1. **Client hello :** 클라이언트가 브라우저 검색창에 도메인을 입력하는 것으로, 서버에게 연락한다. 이 때 클라이언트는 **브라우저가 지원할 수 있는 암호화 방식(cipher Suite)을 먼저 제시**하고, 랜덤 데이터를 생성하여 추가 전송한다.
        2. **Server hello** : 서버는 클라이언트가 제시한 **암호화 방식 중 하나를 선정**하여 알려줌과 동시에, **서버 자신의 인증서를 전달하며 클라이언트에게 연락**한다. 이 때, 인증서에는 서버의 공개 키가 포함되어 있으며, 클라이언트와 마찬가지로 서버 측에서 생성된 랜덤 데이터 또한 전달된다.
        3. **Client key exchange** : 클라이언트는 미리 주고받은 자신과 서버의 랜덤 데이터를 참고하여, 서버와 암호화 통신을 할 때 사용할 키를 생성한 후, 서버에게 전달한다. 이 때 키는 서버로부터 받은 공개키로 암호화되어 보내진다.
        4. **Finished** : 마지막으로 handShake 과정이 정상적으로 마무리되면, 클라이언트와 서버 모두  finished 메시지를 보내며, 그 후부터는 생성한 키를 이용하여 암호화된 데이터를 주고받는다.
    2. **전송**

       서로 간 협상이 완료되었을 때 SSL 세션이 생성되고, 클라이언트와 서버가 원하는 데이터를 주고 받는다.

    3. **종료**

   [웹사이트 보안을 위한 방법, SSL이란? (feat. SSL과 HTTPS의 차이)](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=skinfosec2000&logNo=222135874222)


---

### 민욱

1. **TCP와 UDP의 차이점에 대해 설명하시오.**

   TCP는 데이터를 얼마나 정확하게, 유실 없이, 순서대로 보내느냐에 중점을 둔 프로토콜이라 볼 수 있다. 신뢰할 수 있는 프로토콜이기 때문에, 대부분 어플리케이션에서 주로 사용하는 프로토콜이다.

   반면 UDP는 TCP와 같이 순서 보장, 데이터 유실 방지 등을 보장하진 못한다. 하지만 TCP가 가지고 있던 3 way handShake로 인한 클라이언트와 서버 간 통신연결 상태 확인을 사용하지 않기 때문에, 일방적으로 데이터를 보낼 수 있다. 그렇기에 단순하고 빠른 특징이 있다. 그래서 주로 동영상이나 음악 등에 주로 UDP를 사용한다.


1. **HTTP 메서드의 GET과 POST에 대해 어떠한 차이가 있는지 설명하시오.**

   GET은 주로 리소스 조회를 하는 데 사용되며, 서버에 전달하고 싶은 데이터는 URL의 query parameter를 통해서 전달한다.

   반면 POST는 GET과 달리 단순히 리소스 조회에 그치는 것이 아닌, 요청한 데이터를 서버에서 처리하고, 메시지 바디를 통해 서버로 요청 데이터를 전달한다. 또한, POST는 서버가 식별하지 않은 새 리소스 생성, 요청 데이터 처리, 다른 메서드로 처리하기 애매한 경우 주로 사용되는 HTTP 메서드로써 다양하게 사용된다.


1. **스레드풀에 대해 설명하시오**

   병렬 작업 처리가 많아지게 되면 스레드가 증가하고, 이에 따른 생성 및 스케줄링으로 인해 CPU의 메모리 사용량이 증가하여 성능 저하로 이어지게 된다.

   그래서 병렬 작업으로 인한 스레드의 무분별한 증가를 막기 위해 스레드 풀을 사용하는데, 스레드 풀은 작업에 사용할 스레드 개수를 정해놓고, 작업 큐에 들어오는 작업들을 제한된 개수의 스레드가 맡아서 처리한다. 그리고 작업이 끝난 스레드는 작업 큐에 있는 새로운 작업을 가져와 처리하게 된다.

   작업 큐에 작업이 쌓일 뿐, 스레드가 생성되는 것은 아니기에 성능 저하가 일어나지 않고, 갑작스런 작업의 증가에도 대처할 수 있게된다.

   [[Java] 스레드 풀이란?](https://steady-coding.tistory.com/548)


1. **OSI 7계층과 그 존재 이유, TCP/IP 4계층에 대해 설명하시오.**

   **컴퓨터 네트워크 프로토콜 디자인과 통신을 기능별로 나눈 것을 보고 OSI 7계층이라고 한다**

   이러한 OSI 7 계층은, **통신용 규약의 표준화를** 이루는 데 큰 도움이 되었고, 현재 네트워크 동작을 나누어 이해하고 개발하는 데 많은 도움이 되므로, 네트워크의 주요 레퍼런스 모델로 활용되고 있다. 현재 주로 사용되고 있는 TCP/IP 또한 이러한 OSI를 기반으로 구성되었다.

   복잡한 데이터 전송 과정을 OSI 7계층으로 나누어 보면 이해하기 쉬우며, **계층별로 표준화된 프로토콜 탬플릿을 통해 계층별 프로토콜을 개발하여 네트워크 구성 요소들을 모듈화할 수 있다**. 이렇게 모듈화된 요소는 기존에 개발된 프로토콜과 연동하여 사용할 수 있다.

   TCP/IP는 이러한 OSI 7계층을 더욱 단순화한 프로토콜 스택이며, 대부분 네트워크에서 사용되는 방식이다. 또한 TCP/IP는 그 역할을 더욱 구분하기 쉽게 나뉘어져 있다.

   가령 어플리케이션 계층 + 프레젠테이션 계층 + 세션 계층 ⇒ 어플리케이션 계층으로 통합되어 그 역할을 명확하게 볼 수 있는 것처럼 말이다. 그외에도 TCP/IP는 트랜스포트 계층, 인터넷 계층, 네트워크 액세스 계층으로 구분되어 있다.